学习笔记

##位运算

### XOR 异或
异或，相同为0，不同为1，也可以用 不进位的加法 来理解。  

x^0=x  
x^1s=~x 1s表示全部位都是1， ~x表示x取反  
x^(~x)=1s
x^x=0
c=a^b==> a^c=b,b^c=a
a^b^c = a^(b^c)


###指定位置的操作
1. 将x最右边的n位清零: x & (~0<<n)
2. 获取x的第n位值(0或1)：(x>>n)&1
3. 获取x的第n为的幂值 x&(1<<(n-1))
4. 仅将第n位置为1：x|(1<<n)
5. 仅将第n位置为0：x&(~(1<<n))
6. 将x最高位至第n位清0： x&((1<<n)-1)
7. 将第n位至第0位清0：x&(~((1<<(n+1))-1))

###判断奇偶性
x%2==1-->(x&1)==1
x%2==0-->(x&1)==0
###取中间值
x/2 --> x>>1
mid=(left+right)/2 --> mid=(left+right)>>1

###清0最低位的1
x = x & (x-1)
###得到最低位的1
x&-x  

###树上的操作
//取队列一半，>=half的都没有孩子，<half的有孩子  
`int half = size >>> 1`

//k的左孩子  
`int leftchildren = (k<<1) + 1  `

//k的右孩子  
`int rightchildren = (k<<1) + 2 ` 

//k的父母  
`Int parent = (k-1)>>>1  `



##排序

###比较排序

比较排序时间复杂度的下限是O(nlgn)

比较排序可以抽象为一颗决策树，从根节点到叶子节点的路径长度表示比较次数，n个元素的决策树有n!个路径，设有n个元素的决策树，树高是h，且已知，叶节点个数≥n!，则根据完全二叉树的叶节点个数的一些性质有决策树叶节点个数≤2^h,从而得出：  
n!<=2^h  
h>=logn!  
根据斯特林公式h>=log((n/e)^n)=O(nlgn)

重点掌握：

####快速排序
应用最广，O(nlgn)，不稳定

####归并排序
统计逆序，O(nlgn)，稳定

####堆排序
topk，O(nlgn)，不稳定


###非比较排序

基数排序
计数排序
桶排序
