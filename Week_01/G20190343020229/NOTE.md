学习笔记

## 1.
方案一，先 sort 然后从小往大选，不对，这样丢了下标了……
把减的操作挪到判断后面之后 96 %

方案二：用字典来存每个数字的下标和它对应的匹配数字
漏洞：第一次存的时候，判断条件没有写对（即用来比较的值也是去要匹配的）

## 21
归并排序的感觉，长度没有限定，两个指针一直遍历到结尾，终止条件：某一个长度为零（next为None）
1. 没考虑到 [] 空链表
2. 涉及比较数字大小操作的时候必须用 .val，但是判断是否存在值（None）可以直接用节点
3. 弱点：对于链表的指针的引用会不确定
4. 参考简洁写法之后运行时间并没有增加（思路一致）
5. 在新建 ListNode 的时候最开始我直接用了某个节点，导致返回的值都不对，看起来很奇怪输出的是有节点的数组，后来发现应该用 .val 新建

## 26
最开始没有注意到在删除的过程里面长度会变化
参考解法里面，需要注意最终返回的长度是根据 i 指针来定的。

## 66
- 边界点：进一位的处理，进一位之后已经到头了的处理
- 延伸：这里因为只是加一，所以每次的进一位的数字只会是1，但如果是两个数字相加，就不会是这样了，就要考虑相加之后，这时候大概是应该取商
- case: [9] 忘记移位下标 i 了
- 发现了 return 的好处，是在 break 循环的同时还可以返回值

## 88
- 用冒号操作时候，[l, r] 后面是开区间
- 边界情况：p1 一开始就负数，进不去处理，就需要直接拼，但是拼的条件，是 p2 还需要拼的时候（p2 >= 0），数没有走完

## 42
- 思路：从两端往中间遍历，哪边大就处理哪边的墙，如果小于本侧最大值，就可以积攒雨水。
