学习笔记
### 本周收获
主要是做题思维的收获，写程序就是if else loop recursion，解决算法问题最重要的就是找重复性. 做题的时候先理解清楚题的意思，然后根据方法，5到10分钟思考。
思考不出来就直接看题解进行背诵，然后默写，写完后去寻求反馈，看看别人怎么写的，学习思路和优化自己的代码。

解决每个题的时候，不可能枚举所有的可能，最好能够找到最近重复的子问题进行解题。

学习的技术点：

1. 学习了双指针方法，左右夹逼，不过运用的不是很熟练这块还底练。
2. 学习了遍历不重复的方法. i<length - 1和j = i+1
3. 学习了移动重复项的双指针思路
4. 学习了递归加缓存解决重复问题
5. 使用stack解决先进后出和进相关性的问题.

### 习题思路

283:
解题方法:
1. 遇到0就将0删除然后添加到末尾 O(n^2)
2. 临时数组 O(n) 需要额外空间
3. 使用2个标示位，一次loop, 当`nums[i] != 0`时，将`nums[i]`和`nums[j]`swap，并且`j++`
4. 滚雪球，和3最后算法感觉是一样的，只是思路很好.

11:
解题方法:
1. 暴力法. 找出最大面积， `max(min(height[j],height[i]) * j-i)` O(n^2) 超时了
2. 双指针. O(n)

70:
1. 傻递归 f(n) = f(n-1) + f(n-2) n(n^2) 
2. 缓存 o(n)
3. loop 斐波拉契数列 o(n)

15:
1. 暴力. 3循环 i,j,k ijk == 0 ze add O(n^3)
2. 加一层缓存. O(n^2)


189:
1. 暴力 O(n^2)
2. 额外数组 O(n) O(n) 
3. reverse O(n)
4. 环状替换 TODO

15:
1. 合并后排序 O(nlogn)
2. 双指针 O(n) O(n)
3. 双指针 / 从后往前 o(n) o(1)

66:
1. 先将数组转化为数字，然后加1，再转成 array
2. 小于9，+1直接返回。大于9进位，最后加一位。

20:
1. 暴力法, 不断的替换
2. stack 