学习笔记



   DP题解决步骤:
   1) 设计状态表达式: dp[i][j]的含义, dp矩阵的大小有限, 所以状态的定义都是离散值，即状态取值优先。常见的状态模式如下:
      - src[:i+1], tgt[:j+1]: 两个输入的尾部
      - src[:i+1]: 尾部
      - src[i:j+1]: 首尾
      - 以src[i]结尾的子序列(subsequence)/子串(substring
   2) 设计状态转移方程
   3) 压缩状态空间, 降低空间复杂度


     在限制条件下求解能获取的最大利润：
     - n只股票
     - 你最多可以完成k笔交易
     - 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）

     状态定义:
     dp[i][j][m] 表示第i天结束时、最多j笔交易、持有m只股票时手上的现金，和上面的限制条件一一对应:
     - i: 代表第i天, $0 \le i \le n-1$
     - j: 最多j笔交易, $0 \le j \le k$
     - m: 持有股票数量, $m \in \{0, 1\}$

     状态转移方程:
     - dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j][1] + prices[i])
       - 第i-1天结束时、最多交易j次、不持有股票: *不操作*
       - 第i-1天结束时、做多交易j次、持有股票: *卖出股票* （买入卖出股票算交易一次, 准确的说是最多j次买入股票 ）
     - dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])
       - 第i-1天结束时、最多交易j次、持有股票: *不操作*
       - 第i-1天结束时、最多交易j-1次、不持有股票: *买入*

     状态初始条件:
     - j=0: dp[i][0][0], dp[i][0][1] = 0, -inf
     - i=0: dp[0][j][0], dp[0][j][1] = 0, -prices[i] (for j>=1)
       #+begin_src python
         i = 0
         for j in range(1, k+1):
             dp[i][j][0], dp[i][j][1] = 0, -prices[i]
       #+end_src
